/*
 * Copyright (c) 2022, WSO2 LLC. (http://www.wso2.com). All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package io.ballerina.openapi.core.typegenerator;

import io.ballerina.compiler.syntax.tree.ArrayTypeDescriptorNode;
import io.ballerina.compiler.syntax.tree.IdentifierToken;
import io.ballerina.compiler.syntax.tree.NameReferenceNode;
import io.ballerina.compiler.syntax.tree.Node;
import io.ballerina.compiler.syntax.tree.NodeList;
import io.ballerina.compiler.syntax.tree.QualifiedNameReferenceNode;
import io.ballerina.compiler.syntax.tree.RecordFieldNode;
import io.ballerina.compiler.syntax.tree.RecordTypeDescriptorNode;
import io.ballerina.compiler.syntax.tree.SimpleNameReferenceNode;
import io.ballerina.compiler.syntax.tree.SyntaxKind;
import io.ballerina.compiler.syntax.tree.SyntaxTree;
import io.ballerina.compiler.syntax.tree.Token;
import io.ballerina.compiler.syntax.tree.TypeDefinitionNode;
import io.ballerina.compiler.syntax.tree.TypeDescriptorNode;
import io.ballerina.compiler.syntax.tree.TypeReferenceNode;
import io.ballerina.compiler.syntax.tree.UnionTypeDescriptorNode;
import io.ballerina.openapi.core.typegenerator.generators.RecordTypeGenerator;
import io.ballerina.openapi.core.typegenerator.generators.TypeGenerator;
import io.ballerina.openapi.core.typegenerator.model.GeneratorMetaData;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.media.MapSchema;
import io.swagger.v3.oas.models.media.Schema;
import io.ballerina.openapi.core.typegenerator.exception.BallerinaOpenApiException;
import io.ballerina.openapi.core.typegenerator.generators.AllOfRecordTypeGenerator;
import io.ballerina.openapi.core.typegenerator.generators.ArrayTypeGenerator;
import io.ballerina.openapi.core.typegenerator.generators.PrimitiveTypeGenerator;
import io.ballerina.openapi.core.typegenerator.generators.UnionTypeGenerator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;

import static io.ballerina.compiler.syntax.tree.AbstractNodeFactory.createIdentifierToken;
import static io.ballerina.compiler.syntax.tree.AbstractNodeFactory.createSeparatedNodeList;
import static io.ballerina.compiler.syntax.tree.AbstractNodeFactory.createToken;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createRecordFieldNode;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createRecordTypeDescriptorNode;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createSimpleNameReferenceNode;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createTypeDefinitionNode;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createTypeReferenceNode;
import static io.ballerina.compiler.syntax.tree.NodeFactory.createUnionTypeDescriptorNode;
import static io.ballerina.compiler.syntax.tree.SyntaxKind.PUBLIC_KEYWORD;
import static io.ballerina.compiler.syntax.tree.SyntaxKind.RECORD_KEYWORD;
import static io.ballerina.compiler.syntax.tree.SyntaxKind.SEMICOLON_TOKEN;
import static io.ballerina.compiler.syntax.tree.SyntaxKind.TYPE_KEYWORD;
import static io.ballerina.openapi.core.typegenerator.GeneratorUtils.convertOpenAPITypeToBallerina;
import static io.ballerina.openapi.core.typegenerator.GeneratorUtils.escapeIdentifier;
import static io.ballerina.openapi.core.typegenerator.GeneratorUtils.extractReferenceType;

/**
 * This class wraps the {@link Schema} from openapi models inorder to overcome complications
 * while populating syntax tree.
 *
 * @since 1.3.0
 */
public class BallerinaTypesGenerator {
    /**
     * This public constructor is used to generate record and other relevant data type when the nullable flag is
     * enabled in the openapi command.
     *
     * @param openAPI    OAS definition
     * @param isNullable nullable value
     * @param  typeDefinitionNodeList list of types generated by earlier generations
     */
    public BallerinaTypesGenerator(OpenAPI openAPI, boolean isNullable,
                                   List<TypeDefinitionNode> typeDefinitionNodeList) {
        GeneratorMetaData.createInstance(openAPI, isNullable, false);
    }

    /**
     * This public constructor is used to generate record and other relevant data type when the nullable flag is
     * enabled in the openapi command.
     *
     * @param openAPI    OAS definition
     * @param isNullable nullable value
     */
    public BallerinaTypesGenerator(OpenAPI openAPI, boolean isNullable) {
        GeneratorMetaData.createInstance(openAPI, isNullable, false);
    }

    /**
     * This public constructor is used to generate record and other relevant data type when the absent of the nullable
     * flag in the openapi command.
     *
     * @param openAPI OAS definition
     */
    public BallerinaTypesGenerator(OpenAPI openAPI) {
        GeneratorMetaData.createInstance(openAPI, false, false);
    }

    /**
     * This public constructor is used to generate record and other relevant data type when the nullable flag is
     * enabled in the openapi command.
     *
     * @param openAPI    OAS definition
     * @param isNullable nullable value
     * @param generateServiceType indicate whether the service generation includes service type
     */
    public BallerinaTypesGenerator(OpenAPI openAPI, boolean isNullable, boolean generateServiceType) {
        GeneratorMetaData.createInstance(openAPI, isNullable, generateServiceType);
    }

    public SyntaxTree generateTypeSyntaxTree() throws BallerinaOpenApiException {// ToDo: remove this method
        return null;
    }

    public SimpleNameReferenceNode getSimpleNameReferenceNode(String name) {
        return createSimpleNameReferenceNode(createIdentifierToken(name));
    }

    /**
     * Generate typeDescriptor for given schema.
     */
    public Optional<TypeDescriptorNode> generateTypeDescriptorNodeForOASSchema(Schema<?> schema, HashMap<String, TypeDefinitionNode> subTypesMap, HashMap<String, NameReferenceNode> pregeneratedTypeMap)
            throws BallerinaOpenApiException {
        if (schema == null) {
            return Optional.empty();
        }

        if (schema.get$ref() != null) {
            String schemaName = GeneratorUtils.getValidName(extractReferenceType(schema.get$ref()), true);
            String typeName = escapeIdentifier(schemaName);
            if (!pregeneratedTypeMap.containsKey(typeName)) {
                pregeneratedTypeMap.put(typeName, getSimpleNameReferenceNode(typeName));
                TypeGenerator typeGenerator = TypeGeneratorUtils.getTypeGenerator(GeneratorMetaData.getInstance().getOpenAPI().getComponents().getSchemas().get(schemaName), GeneratorUtils.getValidName(
                        schemaName.trim(), true), null, subTypesMap, pregeneratedTypeMap);
                TypeDescriptorNode typeDescriptorNode = typeGenerator.generateTypeDescriptorNode();
                TypeDefinitionNode typeDefinitionNode = createTypeDefinitionNode(null,
                        createToken(PUBLIC_KEYWORD),
                        createToken(TYPE_KEYWORD),
                        createIdentifierToken(typeName),
                        typeDescriptorNode,
                        createToken(SEMICOLON_TOKEN));
                subTypesMap.put(typeName, typeDefinitionNode);
            }
            return Optional.ofNullable(getSimpleNameReferenceNode(typeName));
        } else if (GeneratorUtils.isMapSchema(schema)) {
            RecordTypeGenerator recordTypeGenerator = new RecordTypeGenerator(schema, null, subTypesMap, pregeneratedTypeMap);
            TypeDescriptorNode record = recordTypeGenerator.generateTypeDescriptorNode();
            return Optional.ofNullable(record);
        } else if (GeneratorUtils.getOpenAPIType(schema) != null) {
            String schemaType = GeneratorUtils.getOpenAPIType(schema);
            boolean isPrimitiveType = schemaType.equals(GeneratorConstants.INTEGER) || schemaType.equals(GeneratorConstants.NUMBER) ||
                    schemaType.equals(GeneratorConstants.BOOLEAN) || schemaType.equals(GeneratorConstants.STRING);
            if (GeneratorUtils.isArraySchema(schema)) {
                ArrayTypeGenerator arrayTypeGenerator = new ArrayTypeGenerator(schema, null, schemaType, subTypesMap, pregeneratedTypeMap);
                return arrayTypeGenerator.getTypeDescNodeForArraySchema(schema, subTypesMap);
            } else if (isPrimitiveType) {
                PrimitiveTypeGenerator primitiveTypeGenerator = new PrimitiveTypeGenerator(schema, null, subTypesMap, pregeneratedTypeMap);
                return Optional.ofNullable(primitiveTypeGenerator.generateTypeDescriptorNode());
                //This returns identifier node for the types: int, float, decimal, boolean, string
//                IdentifierToken identifierToken = createIdentifierToken(
//                        GeneratorUtils.convertOpenAPITypeToBallerina(schema),
//                        AbstractNodeFactory.createEmptyMinutiaeList(), GeneratorUtils.SINGLE_WS_MINUTIAE);
//                return Optional.ofNullable(createSimpleNameReferenceNode(identifierToken));
            } else {
                return Optional.empty();
            }
        } else if (schema.getOneOf() != null) {
            return Optional.ofNullable(getUnionNodeForOneOf(schema, subTypesMap, pregeneratedTypeMap));
        } else if (schema.getAllOf() != null) {
            AllOfRecordTypeGenerator allOfRecordTypeGenerator = new AllOfRecordTypeGenerator(schema, null,
                    subTypesMap, pregeneratedTypeMap);
            return Optional.ofNullable(allOfRecordTypeGenerator.generateTypeDescriptorNode());
        } else if (schema.getAnyOf() != null) {
            UnionTypeGenerator unionTypeGenerator = new UnionTypeGenerator(schema, null, subTypesMap,
                    pregeneratedTypeMap);
            return Optional.ofNullable(unionTypeGenerator.generateTypeDescriptorNode());
        } else {
            return Optional.empty();
        }
    }

    private TypeDescriptorNode getUnionNodeForOneOf(Schema<?> schema, HashMap<String, TypeDefinitionNode> subTypesMap,
                                        HashMap<String, NameReferenceNode> pregeneratedTypeMap)
            throws BallerinaOpenApiException {
        Iterator<Schema> iterator = schema.getOneOf().iterator();
        List<SimpleNameReferenceNode> qualifiedNodes = new ArrayList<>();
        Token pipeToken = createIdentifierToken("|");
        while (iterator.hasNext()) {
            Schema<?> contentType = iterator.next();
            Optional<TypeDescriptorNode> qualifiedNodeType =
                    generateTypeDescriptorNodeForOASSchema(contentType, subTypesMap, pregeneratedTypeMap);
            if (qualifiedNodeType.isEmpty()) {
                continue;
            }
            qualifiedNodes.add((SimpleNameReferenceNode) qualifiedNodeType.get());
        }
        SimpleNameReferenceNode right = qualifiedNodes.get(qualifiedNodes.size() - 1);
        SimpleNameReferenceNode traversRight = qualifiedNodes.get(qualifiedNodes.size() - 2);
        UnionTypeDescriptorNode traversUnion = createUnionTypeDescriptorNode(traversRight, pipeToken,
                right);
        if (qualifiedNodes.size() >= 3) {
            for (int i = qualifiedNodes.size() - 3; i >= 0; i--) {
                traversUnion = createUnionTypeDescriptorNode(qualifiedNodes.get(i), pipeToken,
                        traversUnion);
            }
        }
        return traversUnion;
    }

    /**
     * Create recordType TypeDescriptor.
     */
    public SimpleNameReferenceNode createStatusCodeTypeInclusionRecord(String statusCode, TypeDescriptorNode type,
                                                                       HashMap<String, TypeDefinitionNode> subTypesMap) {
        String recordName = statusCode + GeneratorUtils.getValidName(type.toString(), true);
        Token recordKeyWord = createToken(RECORD_KEYWORD);
        Token bodyStartDelimiter = createIdentifierToken("{|");
        // Create record fields
        List<Node> recordFields = new ArrayList<>();
        // Type reference node
        Token asteriskToken = createIdentifierToken("*");
        QualifiedNameReferenceNode typeNameField = GeneratorUtils.getQualifiedNameReferenceNode(GeneratorConstants.HTTP,
                statusCode);
        TypeReferenceNode typeReferenceNode = createTypeReferenceNode(
                asteriskToken,
                typeNameField,
                createToken(SyntaxKind.SEMICOLON_TOKEN));
        recordFields.add(typeReferenceNode);

        IdentifierToken fieldName = createIdentifierToken(GeneratorConstants.BODY, GeneratorUtils.SINGLE_WS_MINUTIAE,
                GeneratorUtils.SINGLE_WS_MINUTIAE);
        RecordFieldNode recordFieldNode = createRecordFieldNode(
                null, null,
                type,
                fieldName, null,
                createToken(SyntaxKind.SEMICOLON_TOKEN));
        recordFields.add(recordFieldNode);

        NodeList<Node> fieldsList = createSeparatedNodeList(recordFields);
        Token bodyEndDelimiter = createIdentifierToken("|}");

        RecordTypeDescriptorNode recordTypeDescriptorNode = createRecordTypeDescriptorNode(
                recordKeyWord,
                bodyStartDelimiter,
                fieldsList, null,
                bodyEndDelimiter);

        TypeDefinitionNode typeDefinitionNode = createTypeDefinitionNode(null,
                createToken(PUBLIC_KEYWORD),
                createToken(TYPE_KEYWORD),
                createIdentifierToken(recordName),
                recordTypeDescriptorNode,
                createToken(SEMICOLON_TOKEN));
        subTypesMap.put(typeDefinitionNode.typeName().text(), typeDefinitionNode);
        return createSimpleNameReferenceNode(createIdentifierToken(recordName));
    }

    public Optional<TypeDescriptorNode> generateTypeDescriptorForJsonContent(Schema<?> schema, String recordName,
                                                           HashMap<String, TypeDefinitionNode> subTypesMap) throws
            BallerinaOpenApiException {
        Optional<TypeDescriptorNode> returnTypeDecNode =
                generateTypeDescriptorNodeForOASSchema(schema, subTypesMap, new HashMap<>());
        if (returnTypeDecNode.isEmpty()) {
            return Optional.of(getSimpleNameReferenceNode(GeneratorConstants.JSON));
        } else if (returnTypeDecNode.get() instanceof RecordTypeDescriptorNode recordNode) {
            if (recordName == null) {
                return returnTypeDecNode;
            }
            Token rname;
            if (schema.get$ref() != null) {
                rname = createIdentifierToken(GeneratorUtils.getValidName(extractReferenceType(schema.get$ref()), true));
            } else {
                rname = createIdentifierToken(recordName);
            }
            TypeDefinitionNode typeDefinitionNode = createTypeDefinitionNode(null,
                    createToken(PUBLIC_KEYWORD),
                    createToken(TYPE_KEYWORD),
                    rname,
                    recordNode,
                    createToken(SEMICOLON_TOKEN));
            subTypesMap.put(recordName, typeDefinitionNode);
            return Optional.of(recordNode);
        }
        return returnTypeDecNode;
    }

    public Token getQueryParamTypeToken(Schema<?> schema, HashMap<String, TypeDefinitionNode> subTypesMap)
            throws BallerinaOpenApiException {
        if (schema instanceof MapSchema) {
            // handle inline record open
            RecordTypeGenerator recordTypeGenerator = new RecordTypeGenerator(schema, null,
                    subTypesMap, new HashMap<>());
            TypeDescriptorNode recordNode = recordTypeGenerator.generateTypeDescriptorNode();
            return createIdentifierToken(recordNode.toSourceCode(),
                    GeneratorUtils.SINGLE_WS_MINUTIAE,
                    GeneratorUtils.SINGLE_WS_MINUTIAE);
        } else {
            return createIdentifierToken(convertOpenAPITypeToBallerina(schema),
                    GeneratorUtils.SINGLE_WS_MINUTIAE,
                    GeneratorUtils.SINGLE_WS_MINUTIAE);
        }
    }

    public ArrayTypeDescriptorNode getArrayTypeDescriptorNodeFromTypeDescriptorNode(TypeDescriptorNode typeDescriptorNode) {
        return ArrayTypeGenerator.getArrayTypeDescriptorNodeFromTypeDescriptorNode(typeDescriptorNode);
    }
}
